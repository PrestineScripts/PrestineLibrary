local PrestineManager = {}

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

PrestineManager.Config = {
	TravelMethod = "Teleport",
	TweenSpeed = 150,
	TeleportDelay = 0
}

PrestineManager.Profiles = {
	Default = {
		TravelMethod = "Teleport",
		TweenSpeed = 150,
		TeleportDelay = 0
	}
}

PrestineManager.State = {
	Busy = false,
	CurrentTask = "Idle"
}

PrestineManager._perfFlags = {
	Textures = false,
	Effects = false,
	Lighting = false,
	Fog = false,
	Shadows = false,
	RenderDistance = false,
	Water = false,
	LowGraphics = false,
}

PrestineManager._original = {
	Lighting = {},
	Water = {},
	Streaming = {}
}

PrestineManager._token = 0
PrestineManager._queue = {}
PrestineManager._activeTween = nil
PrestineManager._uiConn = nil
PrestineManager._charConn = nil
PrestineManager._deathConn = nil
PrestineManager._fpsConn = nil

PrestineManager._statusParagraph = nil
PrestineManager._serverStatusParagraph = nil
PrestineManager._perfParagraph = nil
PrestineManager._statusSupportsUpdate = nil
PrestineManager._lastStatusText = ""
PrestineManager._lastStatusWarned = false

PrestineManager._lastServerUpdate = 0
PrestineManager._lastPerfUpdate = 0
PrestineManager._fps = 0
PrestineManager._fpsFrames = 0
PrestineManager._fpsLast = os.clock()

PrestineManager._prevCameraSubject = nil
PrestineManager._serverJoinMode = "Lowest"
PrestineManager._spyEnabled = false
PrestineManager._spyTarget = nil

PrestineManager._antiAfk = false
PrestineManager._antiAfkConn = nil

local Cached = {
	Textures = {},
	Effects = {}
}

local function buildCaches()
	table.clear(Cached.Textures)
	table.clear(Cached.Effects)

	local count = 0
	for _, inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("Decal") or inst:IsA("Texture") then
			table.insert(Cached.Textures, inst)
		elseif inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Beam") then
			table.insert(Cached.Effects, inst)
		end

		count += 1
		if count % 200 == 0 then
			task.wait()
		end
	end
end

buildCaches()

task.spawn(function()
	while true do
		task.wait(15)
		buildCaches()
	end
end)

local function getCharacter()
	return player.Character or player.CharacterAdded:Wait()
end

local function getHumanoidRoot()
	local c = getCharacter()
	return c:WaitForChild("Humanoid"), c:WaitForChild("HumanoidRootPart")
end

local function getHumanoid()
	local char = player.Character or player.CharacterAdded:Wait()
	return char:WaitForChild("Humanoid")
end

local function toCFrame(target)
	if typeof(target) == "CFrame" then
		return target
	elseif typeof(target) == "Vector3" then
		return CFrame.new(target)
	elseif typeof(target) == "Instance" and target:IsA("BasePart") then
		return target.CFrame
	end
end

local function isValidMethod(m)
	return m == "Teleport" or m == "Tween" or m == "Walking"
end

local function setClipboard(text)
	if setclipboard then
		local ok = pcall(function() setclipboard(text) end)
		return ok
	elseif toclipboard then
		local ok = pcall(function() toclipboard(text) end)
		return ok
	end
	return false
end

local function clampNumber(v, lo, hi)
	local n = tonumber(v)
	if not n then return nil end
	return math.clamp(n, lo, hi)
end

function PrestineManager:ApplyProfile(name)
	local p = self.Profiles[name]
	if not p then return end
	for k, v in pairs(p) do
		self.Config[k] = v
	end
	if not isValidMethod(self.Config.TravelMethod) then
		self.Config.TravelMethod = "Teleport"
	end
end

function PrestineManager:SetConfig(k, v)
	if self.Config[k] == nil then return end
	self.Config[k] = v
	if k == "TravelMethod" and not isValidMethod(self.Config.TravelMethod) then
		self.Config.TravelMethod = "Teleport"
	end
end

function PrestineManager:Cancel()
	self._token += 1
	self._queue = {}
	self.State.Busy = false
	self.State.CurrentTask = "Cancelled"
	if self._activeTween then pcall(function() self._activeTween:Cancel() end) end
	self._activeTween = nil
end

function PrestineManager:Enqueue(target)
	table.insert(self._queue, target)
end

function PrestineManager:ClearQueue()
	self._queue = {}
end

function PrestineManager:_travel(cf, token)
	local hum, hrp = getHumanoidRoot()
	local method = self.Config.TravelMethod
	if not isValidMethod(method) then
		method = "Teleport"
		self.Config.TravelMethod = method
	end

	if method == "Teleport" then
		hrp.CFrame = cf
		local d = tonumber(self.Config.TeleportDelay) or 0
		local t0 = os.clock()
		while os.clock() - t0 < d do
			if token ~= self._token then return end
			task.wait()
		end
		return
	end

	if method == "Tween" then
		local dist = (hrp.Position - cf.Position).Magnitude
		local speed = math.max(tonumber(self.Config.TweenSpeed) or 1, 1)
		local dur = dist / speed

		local tween = TweenService:Create(
			hrp,
			TweenInfo.new(dur, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{ CFrame = cf }
		)
		self._activeTween = tween

		local completed = false
		local conn
		conn = tween.Completed:Connect(function()
			completed = true
			if conn then conn:Disconnect() end
		end)

		local lastPos = hrp.Position
		local lastMoveT = os.clock()
		tween:Play()

		while not completed do
			if token ~= self._token then
				pcall(function() tween:Cancel() end)
				break
			end

			local p = hrp.Position
			if (p - lastPos).Magnitude > 0.15 then
				lastPos = p
				lastMoveT = os.clock()
			elseif os.clock() - lastMoveT > 2.5 then
				pcall(function() tween:Cancel() end)
				break
			end

			task.wait(0.05)
		end

		self._activeTween = nil
		return
	end

	if method == "Walking" then
		local path = PathfindingService:CreatePath()
		path:ComputeAsync(hrp.Position, cf.Position)
		if path.Status ~= Enum.PathStatus.Success then return end

		for _, wp in ipairs(path:GetWaypoints()) do
			if token ~= self._token then return end

			if wp.Action == Enum.PathWaypointAction.Jump then
				hum:ChangeState(Enum.HumanoidStateType.Jumping)
			end

			local reached = false
			local moveConn
			moveConn = hum.MoveToFinished:Connect(function(ok)
				reached = ok
				if moveConn then moveConn:Disconnect() end
			end)


			hum:MoveTo(wp.Position)

			local t0 = os.clock()
			while not reached do
				if token ~= self._token then
					if moveConn then moveConn:Disconnect() end
					return
				end

				if os.clock() - t0 > 3.0 then
					if moveConn then moveConn:Disconnect() end

					path:ComputeAsync(hrp.Position, cf.Position)
					if path.Status == Enum.PathStatus.Success then
						for _, wp2 in ipairs(path:GetWaypoints()) do
							if token ~= self._token then return end

							if wp2.Action == Enum.PathWaypointAction.Jump then
								hum:ChangeState(Enum.HumanoidStateType.Jumping)
							end

							local reached2 = false
							local c2
							c2 = hum.MoveToFinished:Connect(function()
								reached2 = true
								if c2 then c2:Disconnect() end
							end)

							hum:MoveTo(wp2.Position)

							local t1 = os.clock()
							while not reached2 do
								if token ~= self._token then
									if c2 then c2:Disconnect() end
									return
								end
								if os.clock() - t1 > 3.0 then
									if c2 then c2:Disconnect() end
									return
								end
								task.wait(0.05)
							end
						end
					end

					return
				end

				task.wait(0.05)
			end
		end
	end
end

function PrestineManager:StartQueue()
	if self.State.Busy then return end
	self.State.Busy = true
	self.State.CurrentTask = "Running"

	task.spawn(function()
		self._token += 1
		local token = self._token

		while #self._queue > 0 and token == self._token do
			local target = table.remove(self._queue, 1)
			local cf = toCFrame(target)
			if cf then
				self:_travel(cf, token)
			end
		end

		if token == self._token then
			self.State.Busy = false
			self.State.CurrentTask = "Idle"
		end
	end)
end

function PrestineManager:Travel(target)
	self:Cancel()
	self:Enqueue(target)
	self:StartQueue()
end

function PrestineManager:TravelMultiple(list)
	self:Cancel()
	for _, t in ipairs(list) do
		self:Enqueue(t)
	end
	self:StartQueue()
end

function PrestineManager:_trySetParagraphContent(paragraphObj, text)
	if not paragraphObj then return false end
	local candidates = { "SetContent", "SetText", "Update", "Set", "SetValue" }
	for _, m in ipairs(candidates) do
		local f = paragraphObj[m]
		if typeof(f) == "function" then
			local ok = pcall(function()
				f(paragraphObj, text)
			end)
			if ok then return true end
		end
	end
	return false
end

function PrestineManager:_notify(lib, title, content, dur)
	if not lib then return end
	pcall(function()
		lib:AddNotification({
			TitleText = title,
			ContentText = content,
			Duration = dur or 2
		})
	end)
end

function PrestineManager:_bindCharacterSafety()
	if self._charConn then self._charConn:Disconnect() end
	self._charConn = player.CharacterAdded:Connect(function()
		self:Cancel()
		self.State.CurrentTask = "Respawned"
	end)

	if self._camRespawnConn then self._camRespawnConn:Disconnect() end
	self._camRespawnConn = player.CharacterAdded:Connect(function()
		task.wait(1)
		if PrestineManager._spyEnabled and PrestineManager._spyTarget then
			setCameraToPlayer(PrestineManager._spyTarget)
		end
	end)

	local hum = nil
	pcall(function()
		hum = getCharacter():FindFirstChildOfClass("Humanoid")
	end)

	if self._deathConn then self._deathConn:Disconnect() end
	if hum then
		self._deathConn = hum.Died:Connect(function()
			self:Cancel()
			self.State.CurrentTask = "Died"
		end)
	end
end

local function formatUptime(seconds)
	seconds = math.floor(seconds)

	local s = seconds % 60
	local m = math.floor(seconds / 60) % 60
	local h = math.floor(seconds / 3600) % 24
	local d = math.floor(seconds / 86400) % 7
	local w = math.floor(seconds / 604800)

	local parts = {}
	if w > 0 then table.insert(parts, w .. "w") end
	if d > 0 then table.insert(parts, d .. "d") end
	if h > 0 then table.insert(parts, h .. "h") end
	if m > 0 then table.insert(parts, m .. "m") end
	table.insert(parts, s .. "s")

	return table.concat(parts, " ")
end

local function getServerInfoText()
	local serverType =
		game.PrivateServerId ~= "" and
		(game.PrivateServerOwnerId ~= 0 and "Private" or "Reserved") or
		"Public"

	return "Game Name: " .. game.Name ..
		"\nPlace ID: " .. game.PlaceId ..
		"\nGame ID: " .. game.GameId ..
		"\nServer ID: " .. (game.JobId ~= "" and game.JobId or "N/A") ..
		"\nServer Type: " .. serverType ..
		"\nPlayers: " .. #Players:GetPlayers() .. "/" .. Players.MaxPlayers ..
		"\nUptime: " .. formatUptime(workspace:GetServerTimeNow()) ..
		"\nStreaming Enabled: " .. tostring(workspace.StreamingEnabled) ..
		"\nGravity: " .. tostring(workspace.Gravity)
end

local function getPerformanceText(self)
	return "FPS: " .. tostring(self._fps) ..
		"\nPing: " .. math.floor(player:GetNetworkPing() * 1000) .. " ms"
end

local function getCamera()
	return workspace.CurrentCamera or workspace:WaitForChild("Camera")
end

local function setCameraToPlayer(plr)
	if not plr then return end
	local char = plr.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if hum then
		local cam = getCamera()
		cam.CameraSubject = hum
	end
end

local function resetCamera()
	local char = player.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if hum then
		local cam = getCamera()
		cam.CameraSubject = hum
	end
end

local function getPlayerNames()
	local list = {}
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= player then
			table.insert(list, plr.Name)
		end
	end
	return list
end

local function toggleTextures(state)
	for _, inst in ipairs(Cached.Textures) do
		if inst and inst.Parent then
			if state then
				if inst:GetAttribute("Prestine_T") == nil then
					inst:SetAttribute("Prestine_T", inst.Transparency)
				end
				inst.Transparency = 1
			else
				local t = inst:GetAttribute("Prestine_T")
				if t ~= nil then
					inst.Transparency = t
					inst:SetAttribute("Prestine_T", nil)
				end
			end
		end
	end
end

local function toggleEffects(state)
	for _, inst in ipairs(Cached.Effects) do
		if inst and inst.Parent then
			inst.Enabled = not state
		end
	end
end

local function toggleLighting(state)
	local Lighting = game:GetService("Lighting")
	local o = PrestineManager._original.Lighting

	if state then
		if not o._saved then
			o._saved = true
			o.Brightness = Lighting.Brightness
			o.GlobalShadows = Lighting.GlobalShadows
			o.Ambient = Lighting.Ambient
			o.OutdoorAmbient = Lighting.OutdoorAmbient
			o.Post = {}

			for _, fx in ipairs(Lighting:GetChildren()) do
				if fx:IsA("PostEffect") then
					o.Post[fx] = fx.Enabled
					fx.Enabled = false
				end
			end
		end

		Lighting.Brightness = 1
		Lighting.GlobalShadows = false
		Lighting.Ambient = Color3.new(1,1,1)
		Lighting.OutdoorAmbient = Color3.new(1,1,1)
	else
		if o._saved then
			Lighting.Brightness = o.Brightness
			Lighting.GlobalShadows = o.GlobalShadows
			Lighting.Ambient = o.Ambient
			Lighting.OutdoorAmbient = o.OutdoorAmbient

			for fx, enabled in pairs(o.Post or {}) do
				if fx then fx.Enabled = enabled end
			end
		end
	end
end

local function toggleFog(state)
	local Lighting = game:GetService("Lighting")

	if state then
		if not PrestineManager._original.Lighting._fogSaved then
			PrestineManager._original.Lighting.FogEnd = Lighting.FogEnd
			PrestineManager._original.Lighting.FogStart = Lighting.FogStart
			PrestineManager._original.Lighting._fogSaved = true
		end
		Lighting.FogEnd = 1e6
		Lighting.FogStart = 1e6
	else
		local o = PrestineManager._original.Lighting
		if o._fogSaved then
			Lighting.FogEnd = o.FogEnd
			Lighting.FogStart = o.FogStart
		end
	end
end

local Lighting = game:GetService("Lighting")
local Terrain = workspace:FindFirstChildOfClass("Terrain")

local function toggleShadows(state)
	local Lighting = game:GetService("Lighting")
	local o = PrestineManager._original.Lighting

	if state then
		if o._shadows == nil then
			o._shadows = Lighting.GlobalShadows
		end
		Lighting.GlobalShadows = false
	else
		if o._shadows ~= nil then
			Lighting.GlobalShadows = o._shadows
		end
	end
end

local function toggleRenderDistance(state)
	if state then
		PrestineManager._original.Streaming.Target = workspace.StreamingTargetRadius
		PrestineManager._original.Streaming.Min = workspace.StreamingMinRadius
		workspace.StreamingTargetRadius = 64
		workspace.StreamingMinRadius = 64
	else
		if PrestineManager._original.Streaming.Target then
			workspace.StreamingTargetRadius = PrestineManager._original.Streaming.Target
			workspace.StreamingMinRadius = PrestineManager._original.Streaming.Min
		end
	end
end

local function toggleWater(state)
	if not Terrain then return end

	if state then
		PrestineManager._original.Water = {
			WaveSize = Terrain.WaterWaveSize,
			WaveSpeed = Terrain.WaterWaveSpeed,
			Reflectance = Terrain.WaterReflectance,
			Transparency = Terrain.WaterTransparency
		}

		Terrain.WaterWaveSize = 0
		Terrain.WaterWaveSpeed = 0
		Terrain.WaterReflectance = 0
		Terrain.WaterTransparency = 1
	else
		local o = PrestineManager._original.Water
		if o then
			Terrain.WaterWaveSize = o.WaveSize or Terrain.WaterWaveSize
			Terrain.WaterWaveSpeed = o.WaveSpeed or Terrain.WaterWaveSpeed
			Terrain.WaterReflectance = o.Reflectance or Terrain.WaterReflectance
			Terrain.WaterTransparency = o.Transparency or Terrain.WaterTransparency
		end
	end
end

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")

local function getServerForMode(mode)
	local placeId = game.PlaceId
	local cursor = ""
	local bestServer = nil

	for _ = 1, 5 do
		local url =
			"https://games.roblox.com/v1/games/" .. placeId ..
			"/servers/Public?sortOrder=Asc&limit=100" ..
			(cursor ~= "" and "&cursor=" .. cursor or "")

		local ok, res = pcall(function()
			return game:HttpGet(url)
		end)
		if not ok then return nil end

		local data = HttpService:JSONDecode(res)

		for _, s in ipairs(data.data) do
			if s.playing < s.maxPlayers then
				if mode == "Lowest" then
					if not bestServer or s.playing < bestServer.playing then
						bestServer = s
					end
				elseif mode == "Max" then
					if not bestServer or s.playing > bestServer.playing then
						bestServer = s
					end
				elseif mode == "Full" then
					if s.playing >= s.maxPlayers - 1 then
						return s
					end
				end
			end
		end

		if not data.nextPageCursor then break end
		cursor = data.nextPageCursor
	end

	return bestServer
end

local function applyLowGraphics(state)
	toggleTextures(state)
	toggleEffects(state)
	toggleLighting(state)
	toggleFog(state)
	toggleShadows(state)
	toggleRenderDistance(state)
	toggleWater(state)
end

local VirtualUser = game:GetService("VirtualUser")

local function getHRP()
	local char = player.Character
	return char and char:FindFirstChild("HumanoidRootPart")
end

local function copy(text)
	if setclipboard then
		pcall(function() setclipboard(text) end)
	end
end

function PrestineManager:SetUpStarterUI()
	local PrestineLib = getgenv().PrestineLib
	if not PrestineLib then return end

	self:_bindCharacterSafety()

	PrestineLib:AddSection({ Tab = "Home", MainTitle = "Home" })

	PrestineLib:AddButton({
		Tab = "Home",
		MainName = "Copy YouTube",
		Callback = function()
			local ok = setClipboard("https://www.youtube.com/@PrestineScripts")
			if ok then
				self:_notify(PrestineLib, "Copied", "YouTube link copied to clipboard.", 2)
			else
				self:_notify(PrestineLib, "Unsupported", "Clipboard not supported in this environment.", 3)
			end
		end
	})

	PrestineLib:AddButton({
		Tab = "Home",
		MainName = "Copy Discord",
		Callback = function()
			local ok = setClipboard("https://discord.com/invite/AEmYSz6g4C")
			if ok then
				self:_notify(PrestineLib, "Copied", "Discord invite copied to clipboard.", 2)
			else
				self:_notify(PrestineLib, "Unsupported", "Clipboard not supported in this environment.", 3)
			end
		end
	})

	self._statusParagraph = PrestineLib:AddParagraph({
		Tab = "Home",
		MainTitle = "Character Status",
		paragraphSize = 140,
		MainContent = "Loading..."
	})

	self._serverStatusParagraph = PrestineLib:AddParagraph({
		Tab = "Home",
		MainTitle = "Server Info",
		paragraphSize = 160,
		MainContent = "Loading..."
	})

	self._perfParagraph = PrestineLib:AddParagraph({
		Tab = "Home",
		MainTitle = "Performance",
		paragraphSize = 90,
		MainContent = "Loading..."
	})

	PrestineLib:AddButton({
		Tab = "Home",
		MainName = "Clear Queue",
		Callback = function()
			self:ClearQueue()
			self:_notify(PrestineLib, "Queue", "Queue cleared.", 2)
		end
	})

	PrestineLib:AddButton({
		Tab = "Home",
		MainName = "Cancel Movement",
		Callback = function()
			self:Cancel()
			self:_notify(PrestineLib, "Cancelled", "Movement cancelled.", 2)
		end
	})

	PrestineLib:AddSection({ Tab = "Player", MainTitle = "Player" })
	
	PrestineLib:AddSlider({
		Tab = "Player",
		SliderTitle = "WalkSpeed",
		Min = 0,
		Max = 500,
		DefaultValue = 16,
		Increment = 10,
		Callback = function(v)
			local hum = getHumanoid()
			hum.WalkSpeed = v
		end
	})
	
	PrestineLib:AddSlider({
		Tab = "Player",
		SliderTitle = "Jump Power",
		Min = 0,
		Max = 1000,
		DefaultValue = 50,
		Increment = 10,
		Callback = function(v)
			local hum = getHumanoid()
			hum.UseJumpPower = true
			hum.JumpPower = v
		end
	})

	PrestineLib:AddToggle({
		Tab = "Player",
		MainName = "Infinite Jump",
		DefaultState = false,
		Callback = function(state)
			PrestineManager._infJump = state
		end
	})

	PrestineLib:AddSection({ Tab = "Player", MainTitle = "Player Camera" })

	local names = getPlayerNames()
	PrestineLib:AddDropdown({
	    Tab = "Player",
	    MainTitle = "Select Player",
	    ChoiceList = names,
	    DefaultChoice = names[1] or "None",
	    Multiple = false,
	    Callback = function(v)
	        local name = typeof(v) == "table" and v[1] or v
	        PrestineManager._spyTarget = Players:FindFirstChild(name)
	        if PrestineManager._spyEnabled and PrestineManager._spyTarget then
	            setCameraToPlayer(PrestineManager._spyTarget)
	        end
	    end
	})


	PrestineLib:AddToggle({
		Tab = "Player",
		MainName = "Enable Spy POV",
		DefaultState = false,
		Callback = function(state)
			PrestineManager._spyEnabled = state
	
			local cam = getCamera()
			if not cam then return end
	
			if state then
				PrestineManager._prevCameraSubject = cam.CameraSubject
	
				if PrestineManager._spyTarget then
					setCameraToPlayer(PrestineManager._spyTarget)
				end
			else
				if PrestineManager._prevCameraSubject then
					cam.CameraSubject = PrestineManager._prevCameraSubject
				else
					resetCamera()
				end
			end
		end
	})

	if PrestineManager._infJumpConn then PrestineManager._infJumpConn:Disconnect() end
	PrestineManager._infJumpConn = game:GetService("UserInputService").JumpRequest:Connect(function()
		if not PrestineManager._infJump then return end
		local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
		if hum then
			hum:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end)

	PrestineLib:AddSection({ Tab = "Performance", MainTitle = "Performance" })

	PrestineLib:AddToggle({
		Tab = "Performance",
		MainName = "Turn Off Textures",
		Callback = function(s)
			PrestineManager._perfFlags.Textures = s
			toggleTextures(s)
		end
	})
	
	PrestineLib:AddToggle({
		Tab = "Performance",
		MainName = "Turn Off Effects",
		Callback = function(s)
			PrestineManager._perfFlags.Effects = s
			toggleEffects(s)
		end
	})
	
	PrestineLib:AddToggle({
		Tab = "Performance",
		MainName = "Turn Off Lighting",
		Callback = function(s)
			PrestineManager._perfFlags.Lighting = s
			toggleLighting(s)
		end
	})
	
	PrestineLib:AddToggle({
		Tab = "Performance",
		MainName = "Turn Off Fog",
		Callback = function(s)
			PrestineManager._perfFlags.Fog = s
			toggleFog(s)
		end
	})
	
	PrestineLib:AddToggle({
		Tab = "Performance",
		MainName = "Disable Shadows",
		Callback = function(s)
			PrestineManager._perfFlags.Shadows = s
			toggleShadows(s)
		end
	})
	
	PrestineLib:AddToggle({
		Tab = "Performance",
		MainName = "Reduce Render Distance",
		Callback = function(s)
			PrestineManager._perfFlags.RenderDistance = s
			toggleRenderDistance(s)
		end
	})
	
	PrestineLib:AddToggle({
		Tab = "Performance",
		MainName = "Disable Water Effects",
		Callback = function(s)
			PrestineManager._perfFlags.Water = s
			toggleWater(s)
		end
	})
	
	PrestineLib:AddToggle({
		Tab = "Performance",
		MainName = "Low Graphics Preset",
		Callback = function(s)
			PrestineManager._perfFlags.LowGraphics = s
			applyLowGraphics(s)
		end
	})

	PrestineLib:AddSection({ Tab = "Utility", MainTitle = "Utility" })

	PrestineLib:AddToggle({
		Tab = "Utility",
		MainName = "Anti AFK",
		Callback = function(state)
			PrestineManager._antiAfk = state
	
			if PrestineManager._antiAfkConn then
				PrestineManager._antiAfkConn:Disconnect()
				PrestineManager._antiAfkConn = nil
			end
	
			if state then
				PrestineManager._antiAfkConn = player.Idled:Connect(function()
					VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
					task.wait(1)
					VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
				end)
			end
		end
	})

	PrestineLib:AddButton({
		Tab = "Utility",
		MainName = "Reset Character",
		Callback = function()
			local hum = getHumanoid()
			if hum then hum.Health = 0 end
		end
	})

	PrestineLib:AddButton({
		Tab = "Utility",
		MainName = "Copy Position (CFrame)",
		Callback = function()
			local hrp = getHRP()
			if hrp then
				copy("CFrame.new(" .. tostring(hrp.CFrame) .. ")")
			end
		end
	})

	PrestineLib:AddButton({
		Tab = "Utility",
		MainName = "Copy Position (Vector3)",
		Callback = function()
			local hrp = getHRP()
			if hrp then
				local p = hrp.Position
				copy(("Vector3.new(%.2f, %.2f, %.2f)"):format(p.X, p.Y, p.Z))
			end
		end
	})

	PrestineLib:AddSection({ Tab = "Utility", MainTitle = "Server Hop" })
	
	PrestineLib:AddDropdown({
		Tab = "Utility",
		MainTitle = "Join Server Type",
		ChoiceList = { "Lowest", "Max", "Full" },
		DefaultChoice = "Lowest",
		Multiple = false,
		Callback = function(v)
			PrestineManager._serverJoinMode = typeof(v) == "table" and v[1] or v
		end
	})
	
	PrestineLib:AddButton({
		Tab = "Utility",
		MainName = "Join Server",
		Callback = function()
			local server = getServerForMode(PrestineManager._serverJoinMode)
			if server and server.id then
				TeleportService:TeleportToPlaceInstance(
					game.PlaceId,
					server.id,
					player
				)
			end
		end
	})

	PrestineLib:AddButton({
		Tab = "Utility",
		MainName = "Rejoin Server",
		Callback = function()
			TeleportService:Teleport(game.PlaceId, player)
		end
	})

	PrestineLib:AddButton({
		Tab = "Utility",
		MainName = "Rejoin New Server",
		Callback = function()
			TeleportService:TeleportToPlaceInstance(game.PlaceId, nil, player)
		end
	})

	PrestineLib:AddSection({ Tab = "Settings", MainTitle = "Movement" })

	PrestineLib:AddDropdown({
		Tab = "Settings",
		MainTitle = "Travel Method",
		ChoiceList = { "Teleport", "Tween", "Walking" },
		Multiple = false,
		DefaultChoice = tostring(self.Config.TravelMethod),
		Callback = function(v)
			local m = typeof(v) == "table" and v[1] or v
			if not isValidMethod(m) then m = "Teleport" end
			self.Config.TravelMethod = m
			self:_notify(PrestineLib, "Updated", "Travel Method: " .. m, 2)
		end
	})

	PrestineLib:AddSlider({
		Tab = "Settings",
		SliderTitle = "Tween Speed",
		Min = 50,
		Max = 600,
		DefaultValue = self.Config.TweenSpeed,
		Increment = 10,
		Callback = function(v)
			self.Config.TweenSpeed = v
		end
	})

	PrestineLib:AddInput({
		Tab = "Settings",
		MainTitle = "Teleport Delay",
		PlaceHolder = "Seconds (0 - 10)",
		Callback = function(v)
			local n = clampNumber(v, 0, 10)
			if n ~= nil then
				self.Config.TeleportDelay = n
			end
		end
	})

	PrestineLib:AddKeybind({
	    Tab = "Settings",
	    MainTitle = "Toggle UI",
	    DefaultKey = Enum.KeyCode.RightShift,
	    Callback = function(key)
			PrestineLib.GUIHotkey = key
	    end
	})

	PrestineLib:AddSaveToggle({
		Tab = "Settings",
		MainName = "Auto Save Config",
		DefaultState = true
	})

	if self._uiConn then
		self._uiConn:Disconnect()
		self._uiConn = nil
	end
	
	self._uiConn = task.spawn(function()
		while PrestineLib and PrestineLib.Open do
			task.wait(0.25)
	
			local char = player.Character
			if not char then continue end
	
			local hum = char:FindFirstChildOfClass("Humanoid")
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if not hum then continue end
	
			local ws = hum.WalkSpeed
			local jp = hum.UseJumpPower and hum.JumpPower or hum.JumpHeight
			local hp = hum.Health
			local mhp = hum.MaxHealth
	
			local statusText =
				"Task: " .. tostring(self.State.CurrentTask) ..
				"\nQueue: " .. #self._queue ..
				"\nMethod: " .. self.Config.TravelMethod ..
				"\nTweenSpeed: " .. self.Config.TweenSpeed ..
				"\nTeleportDelay: " .. self.Config.TeleportDelay ..
				"\nWalkSpeed: " .. ws ..
				"\nJump: " .. jp ..
				"\nHealth: " .. string.format("%.0f/%.0f", hp, mhp)
	
			if hrp then
				statusText ..=
					"\nState: " .. hum:GetState().Name ..
					"\nRoot Anchored: " .. tostring(hrp.Anchored)
			end
	
			if statusText ~= self._lastStatusText then
				self._lastStatusText = statusText
				local ok = self:_trySetParagraphContent(self._statusParagraph, statusText)
				if not ok and not self._lastStatusWarned then
					self._lastStatusWarned = true
					self:_notify(
						PrestineLib,
						"Notice",
						"Status paragraph cannot be updated by this PrestineLib build.",
						4
					)
				end
			end
	
			if os.clock() - self._lastServerUpdate >= 1 then
				self._lastServerUpdate = os.clock()
				if self._serverStatusParagraph then
					self:_trySetParagraphContent(
						self._serverStatusParagraph,
						getServerInfoText()
					)
				end
			end
	
			if os.clock() - self._lastPerfUpdate >= 0.5 then
				self._lastPerfUpdate = os.clock()
				if self._perfParagraph then
					self:_trySetParagraphContent(
						self._perfParagraph,
						getPerformanceText(self)
					)
				end
			end
		end
	end)

	if self._uiConn then
		task.cancel(self._uiConn)
		self._uiConn = nil
	end

	self._fpsConn = task.spawn(function()
		while PrestineLib and PrestineLib.Open do
			local frames = 0
			local start = os.clock()
	
			while os.clock() - start < 1 do
				frames += 1
				task.wait()
			end
	
			PrestineManager._fps = frames
		end
	end)
end

return PrestineManager
